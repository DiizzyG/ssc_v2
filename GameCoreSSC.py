from GameMsg import gameMsg

class gameState:
    INIT = 'INIT' # waiting for player id
    CHOOSE = 'CHOOSE' # waiting for players to submit their choises
    GAMEOVER = 'GAMEOVER' # players submitted their choises and a result is returned



class gameCoreSSC():

    def __init__(self,player_num:int):
        self.player_num = player_num
        self.num_player_added = 0 # number of player added to player list
        self.player_list = []
        # player_id for every player
        self.player_choise = {}
        # None/'石头'/'剪刀'/'布'
        self.game_winner = None
        # player_id of the winner, or 'draw' for a draw, None means no winner
        self.game_msg = gameMsg()
        ###############
        self.state = gameState.INIT

    def get_state(self):
        return self.state
    
    def interact(self,msg_dict):
        '''interact with the game core.
        input:
            msg_dict: a message dict
        return:
            rspc_dict: responce dict
        '''
        if self.state == gameState.INIT:
            rspc_dict = self._process_init(msg_dict)
        elif self.state == gameState.CHOOSE:
            rspc_dict = self._process_choose(msg_dict)
        elif self.state == gameState.GAMEOVER:
            rspc_dict = self._process_gameover(msg_dict)
        return rspc_dict

    def _process_init(self,msg_dict):
        ''' 
        input:
            msg_dict for init:
            {   'event_type': 'to_game',
                'event_act': 'add_player',
                'event_obj': player_id (string, generated by uuid4)
            }
        return:
            msg_dict for return:
            'event_type': 'to_all_players'
            if player add successful, and waiting for next player to be added:
                'event_act': 'confirm_player_added,wait_more'
                'event_obj': player_id (player added this time)
            elif player add successful, and enough players for the game, game state change to CHOOSE:
                'event_act': 'confirm_player_added,enough'
                'event_obj': player_id (player added this time)
            elif player added unsuccessful
                'event_act': 'fail_to_add_player'
                'event_obj': player_id (player failed to be added)
        '''
        if msg_dict['event_act'] == 'add_player':
            if self.check_player_full == True:
                return {'event_type': 'to_all_players',
                        'event_act': 'fail_to_add_player',
                        'event_obj': msg_dict['event_obj']}
            else:
                self.add_player_to_list(msg_dict['event_obj'])
                if self.num_player_added < self.player_num:
                    return {'event_type': 'to_all_players',
                            'event_act': 'confirm_player_added,wait_more',
                            'event_obj': msg_dict['event_obj']}
                elif self.num_player_added == self.player_num:
                    # init self.player_choise
                    # for iplayer_id in self.player_list:
                    #     self.player_choise[iplayer_id] = None
                    self.state = gameState.CHOOSE
                    return {'event_type': 'to_all_players',
                            'event_act': 'confirm_player_added,enough',
                            'event_obj': msg_dict['event_obj']}
                else:
                    RuntimeError('num_player_add > max player number')
        else:
            RuntimeError(f'unknown act: {msg_dict['event_act']}')

    def _process_choose(self,msg_dict):
        '''input:
            msg_dict for init:
            {   'event_type': 'to_game',
                'event_act': 'set_player_choise',
                'event_obj': [player_id (string, generated by uuid4), choise (string) '石头'/'剪刀'/'布']
            }
            or enquiry game winner:
            {   'event_type': 'to_game',
                'event_act': 'enquiry_winner',
                'event_obj': None
            }
        return:
             msg_dict for return:
            'event_type': 'to_all_players'
            if player choose successful, and waiting for next player to choose:
                'event_act': 'confirm_player_choose,wait_more'
                'event_obj': None
            elif player choose successful, all players chosed. state change to GAMEOVER:
                'event_act': 'confirm_winner'
                'event_obj': player_id (the winner) or 'draw'
            else: anything wrong, or a player submit a second choise, refuse:
                'event_act': 'fail_to_player_choose'
                'event_obj': None
        '''
        if msg_dict['event_act'] == 'set_player_choise':
            if self.player_choise[msg_dict['event_obj'][0]] == None:
                self.submit_player_choice(msg_dict['event_obj'][0],msg_dict['event_obj'][1])
                if self.check_all_players_submitted_choise():
                    self.cal_game_winner()
                    self.state = gameState.GAMEOVER
                    return {'event_type': 'to_all_players',
                            'event_act': 'confirm_winner',
                            'event_obj': self.get_game_winner()}
                else: # wait for other players to submit choise
                    return {'event_type': 'to_all_players',
                            'event_act': 'confirm_player_choose,wait_more',
                            'event_obj': None}
            else:
                return {'event_type': 'to_all_players',
                        'event_act': 'fail_to_player_choose',
                        'event_obj': None}
        elif msg_dict['event_act'] == 'enquiry_winner':
            return self.game_msg.waiting_for_other_player()
        else:
            RuntimeError(f'unknown act: {msg_dict['event_act']}')

    def _process_gameover(self,msg_dict):
        '''input:
            msg_dict for init:
            {   'event_type': 'to_game',
                'event_act': 'enquiry_winner',
                'event_obj': None
            }
        return:
             msg_dict for return:
             {  'event_type': 'to_player'
                'event_act': 'confirm_winner'
                'event_obj': player_id (the winner) or 'draw'
             }
        '''
        if msg_dict['event_act'] == 'enquiry_winner':
            return {'event_type': 'to_all_players',
                    'event_act': 'confirm_winner',
                    'event_obj': self.get_game_winner()}


    def add_player_to_list(self,player_id):
        print(f'add player {player_id}')
        self.player_list.append(player_id)
        self.player_choise[player_id] = None
        self.num_player_added += 1

    def submit_player_choice(self,player_id,choise):
        self.player_choise[player_id] = choise
        
    def check_player_full(self):
        if self.num_player_added == self.player_num:
            return True
        else:
            return False
    
    def check_all_players_submitted_choise(self):
        for key in self.player_choise:
            if self.player_choise[key] == None:
                return False
        return True
    
    def cal_game_winner(self):
        print(self.player_choise)
        result = self._result_judge(self.player_choise[self.player_list[0]],self.player_choise[self.player_list[1]])
        if result == 0:
            self.game_winner = 'draw'
        elif result == 1:
            self.game_winner = self.player_list[0]
        elif result == 2:
            self.game_winner = self.player_list[1]

    def _result_judge(self,choise_1,choise_2):
        '''return index of the winner'''
        if choise_1 == choise_2:
            return 0
        if choise_1 == '石头':
            if choise_2 == '剪刀':
                return 1
            elif choise_2 == '布':
                return 2
        elif choise_1 == '剪刀':
            if choise_2 == '布':
                return 1
            elif choise_2 == '石头':
                return 2
        elif choise_1 == '布':
            if choise_2 == '石头':
                return 1
            elif choise_2 == '剪刀':
                return 2
    
    def get_game_winner(self):
        return self.game_winner